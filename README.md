   Tест задания от Яндекса:
   
Раскладка клавиатуры: у нас есть четыре символа (A, B, C, D), связанные с соответствующими цифрами (1, 2, 3, 4) в латинском алфавите. Клавиатура состоит из двух рядов, первый ряд содержит символы 1 и 3, а второй ряд содержит символы 2 и 4.

Абстрактный текст: Абстрактный текст — это "A B C A D", где каждый символ соответствует одному из четырех символов на клавиатуре.

Вычислить неоднородность: нам нужно найти неоднородность при наборе абстрактного текста на заданной раскладке клавиатуры. Неоднородность – это количество неоднородных переходов при наборе текста. При этом неоднородные переходы возникают при переходе от одного ряда к другому:

При переходе с Aна B.
При переходе с Bна C.
При переходе с Aна D.
Есть три гетерогенных перехода.

Оптимальная раскладка клавиатуры: цель состоит в том, чтобы найти раскладку клавиатуры, которая позволяет набирать абстрактный текст с максимальным разнообразием. В этом случае оптимальная раскладка клавиатуры та, которая обеспечивает максимальное количество разнородных переходов.

Возможные раскладки клавиатуры (перестановки):

Ряд 1: 1, 3 | 2 ряд: 2, 4
1 ряд: 1, 2 | 2 ряд: 3, 4
1 ряд: 1, 4 | 2 ряд: 2, 3
Рассчитываем неоднородность для каждого макета:

Первая раскладка: 3 разнородных перехода (A -> B, B -> C, A -> D).
Вторая раскладка: 4 разнородных перехода (A -> B, B -> C, C -> A, A -> D).
Третий макет: 3 разнородных перехода (A -> B, B -> C, C -> A).
Третья раскладка имеет максимальное разнообразие с 3 разнородными переходами.

Выходные данные: выходными данными является количество строк в оптимальной раскладке клавиатуры,
в данном случае равно 3.


1.5. Что можно изучить перед соревнованием?
Самые частые темы, которые могут встретиться на соревновании и последующих собеседованиях:

Возможности стандартной библиотеки

базовая работа со строками и символами;
сортировка и компараторы (функции сравнения объектов);
списки (на массиве и связные);
множества и словари (хеш-таблицы и деревья поиска);
стек и очередь;
очередь с приоритетом (обычно на основе кучи);
встроенный двоичный поиск;
Базовые алгоритмы

двоичный поиск (когда не хватает встроенного);
префиксные суммы;
два указателя;
сортировка событий;
двоичные деревья (не поиска, просто деревья);
Базовые алгоритмы, но для искушенных

динамическое программирование
одномерное (зайчик);
двумерное (черепашка);
рюкзак;
основы теории графов:
хранение;
поиск в глубину;
поиск в ширину;
топологическая сортировка;
кратчайшие пути.
Советуем изучить тренировки Яндекса 1.0, 2.0 и 3.0 для лучшего ознакомления.

легенда;
описание входных данных;
описание выходных данных;
примеры тестов (да, это тоже часть условия);
пояснения к примерам.

Для Python доступны компиляторы PyPy и Python 3. PyPy соответствует Python 3.7.

Важно: в большинстве случаев PyPy выполняет программы быстрее, поэтому авторы задач рекомендуют его для использования.

Но вы можете использовать любой из двух компиляторов. Иногда Python 3 (не PyPy) выполняет некоторый код эффективнее PyPy (но редко). Еще реже у данных компиляторов случается разница в поведении, которая может быть вам критична.

Никакого штрафа за переотправку решения под другим компилятором нет.

Ускорения ввода-вывода

Рекомендуется рассмотреть возможность вывода данных с помощью комбинации:

сбор всех результирующих данных в один массив
приведение элементов данного массива к строкам:
“скрепление” данных строк с помощью функции “join” у выбранного разделителя
Пример: вывод массива целых чисел “ans” в формате “каждое число на новой строке”:

# если ans = [1, 3, 5], то map(str, ans) сделает "1", "3", "5"
ans_str = "\n".join(map(str, ans))
print(ans_str)
Работа с кодами символов

ord(ch) - ord(‘a’) или ord(ch) - ord(‘A’) - номер символа ch в алфавите (зависит от регистра);
chr(pos + ord(‘a’)) или chr(pos + ord(‘A’)) - символ по номеру pos в алфавите (зависит от регистра);
Возможности стандартной библиотеки языка

Очевидно, что это не все возможности, просто элементы из пункта 3.0.3.

sort / sorted;
list (динамический массив);
set / dict - хеш-таблицы;
модуль bisect;
модуль collections: deque, defaultdict;
модуль heapq.

